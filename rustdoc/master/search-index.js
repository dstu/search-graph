var searchIndex = {};
searchIndex["search_graph"] = {"doc":"","items":[[3,"Graph","search_graph","A search graph.",null,null],[0,"mutators","","Support for navigation of a graph that allows modifications to graph\ntopology and full read-write access to graph data.",null,null],[3,"MutChildList","search_graph::mutators","A traversible list of a vertex&#39;s outgoing edges.",null,null],[3,"MutEdge","","Mutable handle to a graph edge (&quot;edge handle&quot;) when edge expansion state is\nunknown.",null,null],[3,"MutNode","","Mutable handle to a graph vertex (&quot;node handle&quot;).",null,null],[3,"MutParentList","","A traversible list of a vertex&#39;s incoming edges.",null,null],[0,"nav","search_graph","Support for navigation of a graph without allowing modifications to graph\ntopology.",null,null],[3,"ChildList","search_graph::nav","A traversible list of a vertex&#39;s outgoing edges.",null,null],[3,"ChildListIter","","Iterator over a vertex&#39;s child edges.",null,null],[3,"Edge","","Immutable handle to a graph edge (&quot;edge handle&quot;).",null,null],[3,"Node","","Immutable handle to a graph vertex (&quot;node handle&quot;).",null,null],[3,"ParentList","","A traversible list of a vertex&#39;s incoming edges.",null,null],[3,"ParentListIter","","Iterator over a vertex&#39;s parent edges.",null,null],[0,"search","search_graph","Data structures and algorithms for local graph search.",null,null],[3,"Stack","search_graph::search","Tracks the path through a graph that is followed when performing local search.",null,null],[3,"StackIter","","Iterates over elements of a search path, in the order in which they were\ntraversed, ending with the head.",null,null],[4,"SearchError","","Errors that may arise during search.",null,null],[13,"ChildBounds","","A search operation selected a child index that was out of bounds.",0,null],[12,"requested_index","search_graph::search::SearchError","The index of the child that was requested.",0,null],[12,"child_count","","The actual number of chidren (which `requested_index` exceeds).",0,null],[13,"ParentBounds","search_graph::search","A search operation selected a parent index that was out of bounds.",0,null],[12,"requested_index","search_graph::search::SearchError","The index of the parent that was requested.",0,null],[12,"parent_count","","The actual number of parents (which `requested_index` exceeds).",0,null],[13,"SelectionError","search_graph::search","A search operation encountered an error.",0,null],[4,"StackItem","","Sum type for path elements. All elements except the head are represented\nwith the `StackItem::Item` variant.",null,null],[13,"Item","","Non-head item, a (vertex, edge) pair.",1,null],[13,"Head","","The path head, which may resolve to a vertex or an unexpanded edge.",1,null],[4,"Traversal","","Indicates which edge of a vertex to traverse. Edges are denoted by a 0-based\nindex. This type is used by functions provided during graph search to\nindicate which child or parent edges to traverse.",null,null],[13,"Child","","Traverse the given child.",2,null],[13,"Parent","","Traverse the given parent.",2,null],[11,"new","search_graph","Creates an empty `Graph` with no vertices or edges.",3,{"inputs":[],"output":{"name":"self"}}],[11,"get_node","","Gets a node handle for the given game state.",3,null],[11,"get_node_mut","","Gets a mutable node handle for the given game state.",3,null],[11,"add_root","","Adds a root vertex (one with no parents) for the given game state and\ndata and returns a mutable handle for it.",3,null],[11,"add_edge","","Adds an edge from the vertex with state data `source` to the vertex with\nstate data `dest`. If vertices are not found for `source` or `dest`,\nthey are added, with the data provided by `source_data` and `dest_data`\ncallbacks.",3,null],[11,"vertex_count","","Returns the number of vertices in the graph.",3,null],[11,"edge_count","","Returns the number of edges in the graph.",3,null],[11,"retain_reachable_from","","Deletes all graph components that are not reachable by traversal\nstarting from each vertex corresponding to the game states in `roots`.",3,null],[11,"get_label","search_graph::nav","Returns the canonical label that is used to address this `Node`.",4,null],[11,"get_id","","Returns an immutable ID that is guaranteed to identify this vertex\nuniquely within its graph. This ID may change when the graph is mutated.",4,null],[11,"get_data","","Returns the data at this vertex.",4,null],[11,"is_leaf","","Returns true iff this vertex has no outgoing edges (regardless of\nwhether they are expanded).",4,null],[11,"is_root","","Returns true iff this vertex has no incoming edges.",4,null],[11,"get_child_list","","Returns a traversible list of outgoing edges.",4,null],[11,"get_parent_list","","Returns a traversible list of incoming edges.",4,null],[11,"len","","Returns the number of edges.",5,null],[11,"is_empty","","Returns true iff there are no outgoing edges.",5,null],[11,"get_source_node","","Returns a node handle for the vertex these edges originate from.",5,null],[11,"get_edge","","Returns an edge handle for the `i`th edge.",5,null],[11,"iter","","Returns an iterator over child edges.",5,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"len","","Returns the number of edges.",7,null],[11,"is_empty","","Returns true iff there are no incoming edges.",7,null],[11,"target_node","","Returns a node handle for the vertex these edges point to.",7,null],[11,"get_edge","","Returns an edge handle for the `i`th edge.",7,null],[11,"iter","","Returns an iterator over parent edges.",7,null],[11,"next","","",8,null],[11,"size_hint","","",8,null],[11,"get_id","","Returns an immutable ID that is guaranteed to identify this edge\nuniquely within its graph.  This ID may change when the graph is\nmutated.",9,null],[11,"get_data","","Returns the data at this edge.",9,null],[11,"get_source","","Returns a node handle for this edge&#39;s source vertex.",9,null],[11,"get_target","","Returns the target of this edge. If the edge is unexpanded, no data will\nbe available. If it is expanded, a node handle will be available.",9,null],[11,"fmt","search_graph::search","",0,null],[11,"fmt","","",0,null],[11,"description","","",0,null],[11,"cause","","",0,null],[11,"new","","Creates a new `Stack` from a mutable reference into a graph.",10,{"inputs":[{"name":"mutnode"}],"output":{"name":"self"}}],[11,"len","","Returns the number of elements in the path. Since a path always has a\nhead, there is always at least 1 element.",10,null],[11,"pop","","Removes the most recently traversed element from the path, if\nany. Returns a handle for any edge that was removed.",10,null],[11,"head","","Returns a read-only view of the head element.",10,null],[11,"to_head","","Consumes the path and returns a mutable view of its head.",10,null],[11,"push","","Grows the path by consulting a function of the current head. If this\nfunction `f` returns `Ok(Some(Traversal::Child(i)))`, then the `i`th\nchild of the current head is pushed onto the path. If it returns\n`Ok(Some(Traversal::Parent(i)))`, then the `i`th parent of the current\nhead is pushed onto the path.",10,null],[11,"iter","","Returns an iterator over path elements. Iteration is in order of\ntraversal (i.e., the last element of the iteration is the path head).",10,null],[11,"item","","Returns the `i`th item of the path. Path items are indexed in order of\ntraversal (i.e., the last element is the path head).",10,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"get_id","search_graph::mutators","Returns an immutable ID that is guaranteed to identify this vertex\nuniquely within its graph. This ID may change when the graph is mutated.",12,null],[11,"get_label","","Returns the canonical label that is used to address this `MutNode`.",12,null],[11,"get_data","","Returns the data at this vertex.",12,null],[11,"get_data_mut","","Returns the data at this vertex, mutably.",12,null],[11,"is_leaf","","Returns true iff this vertex has no outgoing edges (regardless of\nwhether they are expanded).",12,null],[11,"is_root","","Returns true iff this vertex has no incoming edges.",12,null],[11,"get_child_list","","Returns a traversible list of outgoing edges. Its lifetime will be\nlimited to a local borrow of `self`.",12,null],[11,"get_child_list_mut","","Returns a traversible list of outgoing edges. Its lifetime will be\nlimited to a local borrow of `self`.",12,null],[11,"to_child_list","","Returns a traversible list of outgoing edges. `self` is consumed, and\nthe return value&#39;s lifetime will be the same as that of `self`.",12,null],[11,"get_parent_list","","Returns a traversible list of incoming edges. Its lifetime will be\nlimited to a local borrow of `self`.",12,null],[11,"get_parent_list_mut","","Returns a traversible list of incoming edges. Its lifetime will be\nlimited to a local borrow of `self`.",12,null],[11,"to_parent_list","","Returns a traversible list of outgoing edges. `self` is consumed, and\nthe return value&#39;s lifetime will be the same as that of `self`.",12,null],[11,"to_node","","Returns a non-mutating node obtained by converting this node. `self` is\nconsumed, and the return value&#39;s lifetime will be the same as that of\n`self`. The source graph is still considered to have a mutable borrow in\nplay, but the resulting node can be cloned freely.",12,null],[11,"get_node","","Returns a non-mutating node obtained by borrowing this node. Returns a\nvalue whose lifetime is limited to a borrow of `self`.",12,null],[11,"retain_reachable","","Prunes the underlying graph by removing components not reachable from\nthis node.",12,null],[11,"len","","Returns the number of outgoing eges.",13,null],[11,"is_empty","","Returns true iff there are no outgoing edges.",13,null],[11,"get_edge","","Returns an edge handle for the `i`th edge.",13,null],[11,"get_edge_mut","","Returns an edge handle for the `i`th edge. Its lifetime will be limited\nto a local borrow of `self`.",13,null],[11,"to_edge","","Returns an edge handle for the `i`th `self` is consumed, and the return\nvalue&#39;s lifetime will be the same as that of `self`.",13,null],[11,"get_source_node","","Returns a node handle for the vertex these edges originate from. Its\nlifetime will be limited to a local borrow of `self`.",13,null],[11,"get_source_node_mut","","Returns a mutable node handle for the vertex these edges originate\nfrom. Its lifetime will be limited to a local borrow of `self`.",13,null],[11,"to_source_node","","Returns a mutable node handle for the vertex these edges originate\nfrom. `self` is consumed, and the return value&#39;s lifetime will be the\nsame as that of `self`.",13,null],[11,"iter","","Returns an iterator over child edges.",13,null],[11,"add_child","","Adds a child edge to the vertex labeled by `child_label`. If no such\nvertex exists, it is created and associated with the data returned by\n`f`. Returns a mutable edge handle for the new edge, with a lifetime\nlimited to a borrow of `self`.",13,null],[11,"to_add_child","","Adds a child edge to the vertex labeled by `child_label`. If no such\nvertex exists, it is created and associated with the data returned by\n`f`. Returns a mutable edge handle for the new edge.",13,null],[11,"len","","Returns the number of incoming edges.",14,null],[11,"is_empty","","Returns true iff there are no incoming edges.",14,null],[11,"get_target_node","","Returns a node handle for the vertex these edges originate terminate\non. Its lifetime will be limited to a local borrow of `self`.",14,null],[11,"get_target_node_mut","","Returns a mutable node handle for the vertex these edges terminate\non. Its lifetime will be limited to a local borrow of `self`.",14,null],[11,"to_target_node","","Returns a mutable node handle for the vertex these edges terminate\non. `self` is consumed, and the return value&#39;s lifetime will be the same\nas that of `self`.",14,null],[11,"get_edge","","Returns a handle to the `i`th edge. Its lifetime will be limited to a\nlocal borrow of `self`.",14,null],[11,"get_edge_mut","","Returns a mutable handle to the `i`th edge. Its lifetime will be limited\nto a local borrow of `self`.",14,null],[11,"to_edge","","Returns a mutable handle to the `i`th edge. `self` is consumed, and the\nreturn value&#39;s lifetime will be the same as that of `self`.",14,null],[11,"iter","","Returns an iterator over parent edges.",14,null],[11,"add_parent","","Adds a parent edge to the vertex labeled by `parent_label`. If no such\nvertex exists, it is created and associated with the data returned by\n`f`. Returns a mutable edge handle for the new edge, with a lifetime\nlimited to a borrow of `self`.",14,null],[11,"to_add_parent","","Adds a parent edge to the vertex labeled by `parent_label`. If no such\nvertex exists, it is created and associated with the data returned by\n`f`. Returns a mutable edge handle for the new edge.",14,null],[11,"get_id","","Returns an immutable ID that is guaranteed to identify this vertex\nuniquely within its graph. This ID may change when the graph is mutated.",15,null],[11,"get_data","","Returns the data at this edge.",15,null],[11,"get_data_mut","","Returns the data at this edge, mutably.",15,null],[11,"get_target","","Returns the target of this edge. If the edge is unexpanded, no data will\nbe available. If it is expanded, a node handle will be available, with\nits lifetime limited to a local borrow of `self`.",15,null],[11,"get_target_mut","","Returns the target of this edge. If the edge is unexpanded, an\n`EdgeExpander` will be provided. If it is expanded, a mutable node\nhandle will be available. In both cases, lifetimes will be limited to a\nlocal borrow of `self`.",15,null],[11,"to_target","","Returns the target of this edge. If the edge is unexpanded, an\n`EdgeExpander` will be provided. If it is expanded, a mutable node\nhandle will be available. In both cases `self` is consumed, and the\nreturn value&#39;s lifetime will be the same as that of `self`.",15,null],[11,"get_source","","Returns a node handle for the source of this edge. Its lifetime will be\nlimited to a local borrow of `self`.",15,null],[11,"get_source_mut","","Returns a mutable node handle for the source of this edge. Its lifetime\nwill be limited to a local borrow of `self`.",15,null],[11,"to_source","","Returns a mutable node handle for the source of this edge. `self` is\nconsumed, and the return value&#39;s lifetime will be equal to that of\n`self`.",15,null],[11,"to_edge","","Returns a non-mutating edge obtained by converting this edge. `self` is\nconsumed, and the return value&#39;s lifetime will be the same as that of\n`self`. The source graph is still considered to have a mutable borrow in\nplay, but the resulting edge can be cloned freely.",15,null]],"paths":[[4,"SearchError"],[4,"StackItem"],[4,"Traversal"],[3,"Graph"],[3,"Node"],[3,"ChildList"],[3,"ChildListIter"],[3,"ParentList"],[3,"ParentListIter"],[3,"Edge"],[3,"Stack"],[3,"StackIter"],[3,"MutNode"],[3,"MutChildList"],[3,"MutParentList"],[3,"MutEdge"]]};
searchIndex["symbol_map"] = {"doc":"Provides fast mapping of arbitrary values to symbolic identifiers.","items":[[3,"Symbol","symbol_map","A table entry that associates an instance of `T` with an atomic symbol.",null,null],[3,"Table","","The head of a linked list associating `T`s with `SymbolId`s. `SymbolId`\nvalues start at 0 and increase by 1 for each `T` added to the table.",null,null],[3,"TableIntoIter","","Iterator that consumes a table.",null,null],[3,"TableIter","","Iterator over table contents.",null,null],[0,"indexing","","Indexing on top of a `Table`.",null,null],[3,"Ref","symbol_map::indexing","Wrapper for a raw pointer which lets us treat it like a reference.",null,null],[3,"HashIndexing","","HashMap-backed table indexing.",null,null],[4,"Insertion","","Indicates whether the result of a symbol lookup had to create a new table\nentry.",null,null],[13,"Present","","Result came from an item that was already present in table.",0,null],[13,"New","","Result came from an item that was not present in table, and a new entry\nwas created.",0,null],[8,"Indexing","","Provides indexing for a `Table`, so that its elements may be retrieved\nefficiently. Most table lookups should go through an implementation of this\ntrait structure instead of a `Table` directly.",null,null],[16,"Data","","The type `T` of a `Table&lt;T, D&gt;`.",1,null],[16,"Id","","The type `D` of a `Table&lt;T, D&gt;`.",1,null],[10,"from_table","","Returns a new indexing method that has already indexed the contents of\n`table`.",1,{"inputs":[{"name":"table"}],"output":{"name":"self"}}],[10,"table","","Returns a read-only view of the underlying table.",1,null],[10,"to_table","","Extracts the underlying table from the index, discarding all pointers\ninto the table.",1,null],[10,"get","","Looks up `data` in the index. Returns `Some(&amp;symbol)` if a symbol is\npresent, else `None`.",1,null],[10,"get_or_insert","","Looks up `data` in the index, inserting it into the index and `table` if\nit isn&#39;t present. Returns the resulting `&amp;Symbol&lt;T&gt;` wrapped in an\n`Insertion` that indicates whether a new table entry had to be created.",1,null],[10,"get_symbol","","Looks up the symbol with id `i` in the index. Returns `Some(symbol)` if\na symbol is present, else `None`.",1,null],[11,"clone","","",0,null],[11,"cmp","","",0,null],[11,"hash","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"map","","Maps over the type returned by an `Insertion` to produce a new value\nthat may be of a different type.",0,null],[11,"unwrap","","Unwraps an `Insertion` to produce the value which it wraps.",0,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"hash","","",2,null],[11,"cmp","","",2,null],[11,"eq","","",2,null],[11,"partial_cmp","","",2,null],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"from_table","","",3,{"inputs":[{"name":"table"}],"output":{"name":"self"}}],[11,"table","","",3,null],[11,"to_table","","",3,null],[11,"get","","",3,null],[11,"get_or_insert","","",3,null],[11,"get_symbol","","",3,null],[11,"id","symbol_map","Returns the symbol&#39;s ID.",4,null],[11,"data","","Returns a reference to the symbol&#39;s data.",4,null],[11,"hash","","",4,null],[11,"eq","","",4,null],[11,"partial_cmp","","",4,null],[11,"cmp","","",4,null],[11,"new","","Creates a new, empty table.",5,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Returns the number of symbols in the table.",5,null],[11,"insert","","Inserts `value` into the table and assigns it an id. The same value may\nbe inserted more than once. To prevent such operations, use the\n`get_or_insert()` method of `Indexing`.",5,null],[11,"remap","","Remaps associations between `T`s and `D`s, selectively dropping some\nassociations entirely. The addresses of `Symbol&lt;T&gt;`s for entries which\nare retained do not change.",5,null],[11,"into_iter","","",5,null],[11,"iter","","Returns an iterator over table entries.",5,null],[11,"to_hash_map","","Converts `self` to a `HashMap` holding the same associations as\n`self`. If the same key occurs in `self` more than once, then duplicate\noccurrences will be dropped arbitrarily.",5,null],[11,"into_iter","","",5,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"next","","",7,null],[11,"size_hint","","",7,null],[8,"SymbolId","","An atomic ID.",null,null],[10,"next","","Returns the ID immediately subsequent to this one.",8,null],[10,"as_usize","","Casts the ID to a `usize`.",8,null]],"paths":[[4,"Insertion"],[8,"Indexing"],[3,"Ref"],[3,"HashIndexing"],[3,"Symbol"],[3,"Table"],[3,"TableIter"],[3,"TableIntoIter"],[8,"SymbolId"]]};
initSearch(searchIndex);
